We'll Build 3 Projects :

            1) API : Receive HTTP request and respond to them
            2) Infrasctructure : Communicates with the DB and get data
            3) Core : Containes the business entities. Does not depend on anything else

            Reasons : Separation of concernes : every layer has its own responsibility this allows:

                                - Testability
                                - Scalabity and maintainability
                                - Flexability 
                                - Reusability

            dotnet new list : list of all projects we can create with dotnet

                             we'll create a :
                                            solution file : container for our project
                                                            dotnet new sln
                                            webapi :  dotnet new webapi -o API -controllers (to use controllers approach instead of minimal API)

                                            classlib : 
                                                        -dotnet new classlib -o Core
                                                        -dotnet new classlib -o Infrastructure

                            ADD our projects to the solution :
                                        dotnet sln add API
                                        dotnet sln add Core
                                        dotnet sln add Infrastructure




            Dependencies bwtn our projects : API > Infrastructure > CORE

                                            1) ADD API dependecy on Infra : cd API dotnet add reference ../Infrastructure
                                            2) ADD Infrastructure dependeny on Core : cd Infrastructure dotnet add reference ../Core

            dotnet restore : to confirm or register our different projects in solution file
            dotnet build    : make sure we do not have an error on our application 

            cd API : dotnet run   : launch on http://localhost:5268 (nothing)

                    but in Controllers we have
                                    [ApiController]
                                    [Route("[controller]")]
                                    public class WeatherForecastController : ControllerBase

                    meaning in  http://localhost:5268/WeatherForecast we've something

                    Properties : simplify launchSettings.json, here's the simplest version :

                                {
                                    "$schema": "https://json.schemastore.org/launchsettings.json",
                                    "profiles": {
                                        "http": {
                                        "commandName": "Project",
                                        "dotnetRunMessages": true,
                                        "launchBrowser": false,
                                        "applicationUrl": "http://localhost:5000;https://localhost:5001",
                                        "environmentVariables": {
                                            "ASPNETCORE_ENVIRONMENT": "Development"
                                        }
                                        }
                                        
                                        }
                                    }

                    Porgram.cs : simplest version 

                                When an HTTP request comes to our server it going trough a pipeline 

                                Middlewares: allows to interact with those request before it reaches the API endpoints
                                And when the request goes out from API endpoints we can also interact with them using middlewares

                                services : things we inject into classes of our application




                                var builder = WebApplication.CreateBuilder(args);

                                // Add services to the container.

                                builder.Services.AddControllers();

                                
                                // before this  line services

                                var app = builder.Build();

                                // after this line middlewares

                                         // Configure the HTTP request pipeline.



                                        app.UseAuthorization();

                                        app.MapControllers();

                                        app.Run();

                        in API.csproj :

                                <Nullable>enable</Nullable> (to avoid null reference exception)

                    Create our products in CORE/Entities

                                            new file class Product : BaseEntity
                                            new files class BaseEntity  with only id prop
                    
                    Infrastructure: Create Entity Frameworl Class

                                    - Install a couple of packages  by nuget (tab in terminal (uncheck prerelease))
                                     microsoft.entityframeworkcore.SQLserver (+Infrastructure)
                                     microsoft.entityframeworkDesign (+ API.csproj)

                                     - new folder in infrastructure Data
                                     - new file class StoreContext in Data
                                     - StoreContext : DbContext which comes from microsoftEntityFramework

                                    StoreContext.cs

                                     using Microsoft.EntityFrameworkCore;
                                        namespace Infrastructure.Data;
                                        // options : sql connection string
                                        // register this class as a service in our application
                                        public class StoreContext(DbContextOptions options) : DbContext(options)
                                        {
                                        }

                                    To add this service go to program.cs :

                                        // Service to connect to the sql database

                                            builder.Services.AddDbContext<StoreContext>(opt =>
                                            {
                                                opt.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
                                            });


                                        // add this to StoreContext class, "Products" will the name of the table in the database

                                                 public DbSet<Product> Products {get;set;}



                                        // docker-compose.yml in the root of the project 

                                        services:
                                            sql:
                                                image: mcr.microsoft.com/mssql/server:2022-latest
                                                environment:
                                                ACCEPT_EULA: "Y"
                                                MSSQL_SA_PASSWORD: "Password@1"
                                                platform: "linux/amd64"
                                                ports:
                                                - "1433:1433"


                                        docker compose up -d : to run the container

                                        in appsettings.Development.json add : 

                                                                                ,
                                        "ConnectionStrings": {
                                            "DefaultConntection" : "Server=localhost,1433;Database=API_DB;User Id=poulonani;Password=Password@1;TrustServerCerificate=True"
                                        }


                                        Create an EntityFramework called migration : 

                                        install dotnet-ef globaly : dotnet tool install --global dotnet-ef --version 10.0.2
                                                                                                    ,
                                        dotnet ef migrations add InitialCreate -s API -p Infrastructure
                                        warniing : remove migration : dotnet ef migrations remove -s API -p Infrastrucure

                                        Create Product configuration class in Infrastructure to configure database column type

                                        then in store context add  : 

                                         protected override void OnModelCreating(ModelBuilder modelBuilder)
                                            {
                                                base.OnModelCreating(modelBuilder);
                                                modelBuilder.ApplyConfigurationsFromAssembly(typeof(ProductConfiguration).Assembly);
                                            }

                                        dotnet ef database update : to create our database


                                    Creating a product Controller : API new file class ProductController to define type of var to avoid warning in db creation




                                    API Architecture :

                                    API project have controllors and middleware have routing config , api also startup project of our application
                                    Infrastrucure : contains our data access logic dbContext class and services we use such as strip as long as communication with db
                                    Core : we're we create our entities and interfaces, the idea is that an interface can injected in a controllers and an implementation class in our infrastrucutre such as Repository when use it ian our api, we use an interface
                                    [API : Controllers Startup Middleware]  === > [Infrastructure : Repository DbContext ] ==> [ DB Stripe]

                                                                                            |||||
                                                                                            + + +
                                                                                            [Core : Entities Interfaces]    



                                    Repository PAttern : Decouple business code from data access, Separation of concerns avoid direct use of dbcontext, minimize query logic, testability
                                                         Avoid messy controllers
                                                         Simplify testing
                                                         Increased abstraction
                                                         Maintainability 
                                                         Reduce dupolicated code
                                                         - Abstraction of an abstraction

                                                         (InterfaceRepository gives acess tp GetProducts(),GetProduct(int id) to our controller) => Controller

                                                         (Db Context ) => (Repository)   

                                                         (getProducts()) <=> _context.Products.ToList() <=> Selectr* From Products (DB)
                                                         
                                    Core/ :
                                                Create folder interfaces
                                                Create InterfaceFile IProductRepository
                                                In product coontrollers we should be able to do CRUD operations on product and see if product exists
                                                Create ProductRepository class in Infrastructure/Data
                                                ADD REpository as a service on program.cs



                                                Generic Repository to allows to deal with several entities at the same time, here we only have product repository but general takes
                                                Type T as parametern T can be PRoduct or something else .... We should use specification pattern to deal with more complex methods because the only attribute allows for T are the one that derived from the BaseEntiny p.Name will give and error so we use specification patterns

